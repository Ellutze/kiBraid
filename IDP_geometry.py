# -*- coding: utf-8 -*-
"""
Created on Thu Feb 20 10:34:48 2020

@author: jakub.kucera
"""

import numpy as np
import math

#Assembly of geometric tools used for the Integrated Simulations project


def findNormal(MD,point):
    #this function finds normal vector to a surface
    #the surface is provided as a cloud of points (node_mat)
    #the location of the normal is defined by point 
    
    #third dimension of matrix unsuitable for the iteration - simplify matrix
    MD1 = np.zeros([1,3])
    o = 0
    while o < np.size(MD,2) and (point[2] + 20) >= MD[0,3,o]:
        #if  point[2] - 10 < MD[0,0,o] < point[2]+10:   #actually marginally slower to only concatenate selected matrices
        if (point[2] -20) <= MD[0,3,o]:
            MD1 = np.concatenate((MD1,MD[:,1:4,o]),axis=0)
        o = o + 1
    MD1 = np.delete(MD1,0,axis=0)
    
    #Find the nearest 3 points
    CP = np.zeros([3,3])
    ii = 0
    #for each point required
    while ii < 3:
        i = 0
        c = 1000000
        wtd = 0
        #loop through all points available
        while i < np.size(MD1,0):
            #calculate the distance between point and reference point
            dl = np.sqrt((point[0]-MD1[i,0])**2+(point[1]-MD1[i,1])**2+(point[2]-MD1[i,2])**2)
            #if no closer point was found yet, insert it into the CP matrix
            if dl < c :
                CP[ii,:] = np.matrix([MD1[i,0],MD1[i,1],MD1[i,2]])
                c = dl
                wtd = i
            
            i = i + 1

        MD1 = np.delete(MD1,wtd,axis =0) 
        #preventing co-linear points
        ii = ii + 1
        if ii == 3:
            min_dist = 0.7 # TIE THIS TO MESH SIZE ONCE IN THE LOOP

            #Checking that all 3 points are not at the same z location.
            #If they were, invalid normal would be created. 
            #In theory same issue could be created with x or y locations being the same, 
            #however method for preventing this issues has not been created.
            if ((abs(CP[0,2] - CP[1,2]) +abs(CP[0,2] - CP[2,2]))<min_dist):
                ii = ii - 1
                print("nearest correstion")
    #create 2 vectors of the 3 nearest points
    v1 = CP[0,:] - CP[1,:]
    v2 = CP[0,:] - CP[2,:]
    #find the vector perpendicular to the two vectors
    v = np.cross(v1,v2)
    
    #turn into unit vector
    v_mag = np.sqrt((v[0])**2+(v[1])**2+(v[2])**2)
    v = v/v_mag
    #check that vector is pointing away from the origin (assumed at 0,0,0)
    check_point = point + v
    point_d = np.sqrt((point[0])**2+(point[1])**2+(point[2])**2)
    check_point_d = np.sqrt((check_point[0])**2+(check_point[1])**2+(check_point[2])**2)
    if point_d > check_point_d:
        v = v * -1    
    return(v,CP)
    
    
def centreline(MD):
    #finds local centreline vector for the braided part
    cdArr = np.zeros([1,4])
    i = 0
    #Use the matrix of cross sections to find cross section centre-point.
    #Then find the vector from centre-point i to centre-point i+1.
    while i < np.size(MD,2)-1:
        yav = np.average(MD[:,2,i])
        xav = np.average(MD[:,1,i])
        yav2 = np.average(MD[:,2,i+1])
        xav2 = np.average(MD[:,1,i+1])
        vx = xav2 - xav
        vy = yav2 - yav
        if i == 0:
            #the first centre-point is also the datum.
            datum = np.matrix([xav,yav,MD[0,3,i]])
        vz = MD[0,3,i+1]-MD[0,3,i]
        avz = MD[0,3,i]
        temp = np.matrix([vx,vy,vz,avz])
        cdArr = np.concatenate((cdArr,temp),axis = 0)
        i = i + 1
        if i == np.size(MD,2)-1:
            #last section takes the vector of second last section.
            avz = MD[0,3,i]
            temp = np.matrix([vx,vy,vz,avz])
            cdArr = np.concatenate((cdArr,temp),axis = 0)
    cdArr = np.delete(cdArr,0,axis=0)
    np.save("D:\\IDPcode\\temporary\\cdArr.npy", cdArr)
    return(datum,cdArr)
    
def pitch(a,MD,z,spoolsPhy):
    #This function estimates the pitch. It uses mesh generated by numimesh
    #function. The mesh is used to calculate local perimeter. Local braid
    #angle and number of total spools is used to calculate local pitch.
    
    #Find the most appropriate cross section mesh section.
    i = 0
    mindist = 100000
    while i < np.size(MD,2):
        diff = abs(z-MD[0,3,i])
        if diff < mindist:
            mindist = diff
            sec = i
        i = i + 1
    
    #Calculate the lenght of perimeter by adding the distance between 
    #consecutive nodes.
    csL = 0
    i = 0 
    while i < np.size(MD,0):
        if i == (np.size(MD,0)-1):
            localLen = np.sqrt((MD[i,1,sec]-MD[0,1,sec])**2 + (MD[i,2,0]-MD[0,2,sec])**2)
        else:
            localLen = np.sqrt((MD[i,1,sec]-MD[i+1,1,sec])**2 + (MD[i,2,0]-MD[i+1,2,sec])**2)
        csL = csL + localLen
        i = i + 1
        
    #Pitch calculation.
    pitch = (csL/spoolsPhy)*math.cos(a*math.pi/180)
    return(pitch)

    
def xPlaneLine(plane,point_s,point_p,direction):
    #---ANOTATE.... 
    a = point_s[0]
    b = direction[0]
    c = point_s[1]
    d = direction[1]
    aa = point_p[0]
    cc = point_p[1]
    ee = point_p[2]
    e = point_s[2]
    f = direction[2]
    g = plane[0]
    h = plane[1]
    j = plane[2]
    K = -g*aa-h*cc-j*ee
    t = -(g*a+h*c+j*e)/(g*b+h*d+j*f)
    x = a+t*b
    y = c+t*d
    z = e+t*f
    ix = np.array([x,y,z])
    dir_mag = np.sqrt(direction[0]**2+direction[1]**2+direction[2]**2)
    dir2 = direction/dir_mag
    dOR = -K/np.sqrt(g**2+h**2+j**2)
    intersection = ix + dir2*dOR
    
    return(intersection)
 
def xsNormalCloud(CP,point0,normal):
    pos = 0.01
    #precision defines the allowed error from the surface
    dist = 5
    diff = 5
    iterate = 1
    precision = 0.001
    #print(CP)
    i = 0
    while abs(diff) > precision:
        prev_dist = dist
        point = point0 + pos*normal
        dist = math.sqrt((CP[0,0]-point[0])**2 + (CP[0,1]-point[1])**2 + (CP[0,2]-point[2])**2)
        diff = prev_dist - dist
        if diff < 0:
            iterate = iterate*(-1)*0.1

        pos = pos + iterate
        #print(pos)
        #print(point)
        i = i + 1
        if i > 10000:
            print("Too many iterations run, last poc1 will be used")
            diff = 0

    return(point)


def dot(mat1,mat2):
    #print(mat1,mat2)
    mat = []
    if np.size(mat1,1) != np.size(mat2,0):
        print("the number of columns int mat1 has to match number of rows in mat2")
    else:
        m = np.size(mat1,0)
        k = np.size(mat2,1)
        mat = np.zeros([m,k])
        
        i = 0
        while i < m:
            ii = 0
            while ii < k:
                mat[i,ii] = mat1[i,0]*mat2[0,ii]+mat1[i,1]*mat2[1,ii]+mat1[i,2]*mat2[2,ii]
                ii = ii + 1
            i = i + 1
    #print(mat)    
    return(mat)
    
#MD = np.load('D:\\IDPcode\\catiafiles\\meshfiles\\none_A000_JK_N008_nodes.npy')
#centreline(MD)
        
        