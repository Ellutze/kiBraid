# -*- coding: utf-8 -*-
"""
Created on Thu Feb 20 10:34:48 2020

@author: jakub.kucera
"""
import numpy as np
import math

#Assembly of geometric tools
    
def centreline(MD):
    #finds local centreline vector for the braided part
    cdArr = np.zeros([1,4])
    i = 0
    #Use the matrix of cross sections to find cross section centre-point.
    #Then find the vector from centre-point i to centre-point i+1.
    while i < np.size(MD,2)-1:
        yav = np.average(MD[:,2,i])
        xav = np.average(MD[:,1,i])
        yav2 = np.average(MD[:,2,i+1])
        xav2 = np.average(MD[:,1,i+1])
        vx = xav2 - xav
        vy = yav2 - yav
        if i == 0:
            #the first centre-point is also the datum.
            datum = np.matrix([xav,yav,MD[0,3,i]])
        vz = MD[0,3,i+1]-MD[0,3,i]
        avz = MD[0,3,i]
        temp = np.matrix([vx,vy,vz,avz])
        cdArr = np.concatenate((cdArr,temp),axis = 0)
        i = i + 1
        if i == np.size(MD,2)-1:
            #last section takes the vector of second last section.
            avz = MD[0,3,i]
            temp = np.matrix([vx,vy,vz,avz])
            cdArr = np.concatenate((cdArr,temp),axis = 0)
    cdArr = np.delete(cdArr,0,axis=0)
    return(datum,cdArr)
    
def pitch(a,MD,z,spoolsPhy):
    #This function estimates the pitch. It uses mesh generated by mesh_anyshape
    #script. The mesh is used to calculate local perimeter. Local braid
    #angle and number of total spools is used to calculate local pitch.
    
    #Find the most appropriate cross section mesh section.
    i = 0
    mindist = 100000
    while i < np.size(MD,2):
        diff = abs(z-MD[0,3,i])
        if diff < mindist:
            mindist = diff
            sec = i
        i = i + 1
    
    #Calculate the lenght of perimeter by adding the distance between 
    #consecutive nodes.
    csL = 0
    i = 0 
    while i < np.size(MD,0):
        if i == (np.size(MD,0)-1):
            localLen = np.sqrt((MD[i,1,sec]-MD[0,1,sec])**2 + (MD[i,2,0]-MD[0,2,sec])**2)
        else:
            localLen = np.sqrt((MD[i,1,sec]-MD[i+1,1,sec])**2 + (MD[i,2,0]-MD[i+1,2,sec])**2)
        csL = csL + localLen
        i = i + 1
        
    #Pitch calculation.
    pitch = (csL/spoolsPhy)*math.cos(a*math.pi/180)
    return(pitch)      
        